```python
from flask import Flask, request, jsonify
from werkzeug.security import check_password_hash
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'
app.config['TOKEN_EXPIRATION'] = 3600  # 1 hour token expiration

# Sample user data, typically this would come from a database
users = {
    'john_doe': 'pbkdf2:sha256:150000$gZ1kL1OK$c6f2c8e...f3e8',  # hashed password
}

def verify_user(username, password):
    """Verify if the provided username and password match."""
    if username in users:
        # Compare the provided password with the stored hashed password
        return check_password_hash(users[username], password)
    return False

def generate_auth_token(username):
    """Generate a token for the specified user."""
    s = Serializer(app.config['SECRET_KEY'], expires_in=app.config['TOKEN_EXPIRATION'])
    return s.dumps({'username': username}).decode('utf-8')

@app.route('/login', methods=['POST'])
def login():
    """Handle login requests and return an auth token if credentials are valid."""
    data = request.get_json()
    
    username = data.get('username')
    password = data.get('password')

    if not username or not password:
        return jsonify({'message': 'Missing username or password'}), 400
    
    if verify_user(username, password):
        token = generate_auth_token(username)
        return jsonify({'token': token}), 200
    else:
        return jsonify({'message': 'Invalid username or password'}), 401

if __name__ == '__main__':
    app.run(debug=True)
```

- The `Flask` application is initialized and configured with a secret key.
- A sample user dictionary contains usernames mapped to hashed passwords, which you would normally store in and query from a database.
- The `verify_user()` function checks if the username exists and if the provided password matches the stored hash.
- `generate_auth_token()` creates a token using itsdangerous library which is valid for a specified duration.
- The `/login` route handles `POST` requests. It checks whether the username and password are provided and valid. If they are, it responds with a token. Otherwise, it sends an error response.